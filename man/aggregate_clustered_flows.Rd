% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/linestring_aggregation.R
\name{aggregate_clustered_flows}
\alias{aggregate_clustered_flows}
\title{Aggregate clustered OD flows into representative lines}
\usage{
aggregate_clustered_flows(flows, weight = NULL, crs = sf::st_crs(flows))
}
\arguments{
\item{flows}{An \code{sf} object containing OD flows with coordinates for origins
(\code{x}, \code{y}) and destinations (\code{u}, \code{v}), a \code{cluster} column, and optionally
a \code{count} or other weighting variable.}

\item{weight}{(optional) Name of a column in \code{flows} to use for weighting.
If \code{NULL} (default), unweighted means are used.}

\item{crs}{Coordinate reference system for the output (default: taken from
\code{flows}).}
}
\value{
An \code{sf} object with one line per cluster, containing:
\itemize{
\item \code{count_total}: total weight (if provided), otherwise number of flows
\item \code{size}: the cluster size (from the input, not recomputed)
\item \code{geometry}: a \code{LINESTRING} representing the aggregated OD flow
}
}
\description{
This function aggregates flows within clusters and creates a single
representative line for each cluster. The start and end coordinates are
computed as weighted averages (weighted by flow counts or another variable),
or simple means if no weights are provided. Each cluster is represented
by one \code{LINESTRING}.
}
\examples{
# ----- 1. Prepare the data

flows <- sf::st_transform(flows_leeds, 3857)
# Add flow lengths and coordinates
flows <- add_flow_length(flows)
# filter by length
flows <- filter_by_length(flows, length_min = 5000, length_max = 12000)
flows <- add_xyuv(flows)
# Calculate distances
distances <- flow_distance(flows, alpha = 1.5, beta = 0.5)
dmat <- distance_matrix(distances)
wvec <- weight_vector(dmat, flows, weight_col = "count")

# Cluster flows using DBSCAN
flows_clustered <- cluster_flows_dbscan(dmat, wvec, flows, eps = 8, minPts = 70)

# Filter out noise points and small clusters. Calculate size and count per cluster
flows_clustered <- flows_clustered |>
  dplyr::filter(cluster != 0) |> # these are normally the noisepoints
  dplyr::group_by(cluster) |>
  dplyr::mutate(size = dplyr::n(),
         count_cluster = sum(count)) |>
  dplyr::ungroup() |>
  # keep the biggest 9 clusters only (in terms of size)
  dplyr::arrange(dplyr::desc(size)) |>
  dplyr::slice_head(n = 9) 
  
         
# ----- 2. Aggregation code

# Weighted aggregation (by flow counts)
flows_agg_w <- aggregate_clustered_flows(flows_clustered, weight = "count")
head(flows_agg_w)

# Unweighted aggregation
flows_agg_uw <- aggregate_clustered_flows(flows_clustered)
head(flows_agg_uw)

# ----- 3. Visualize the output ---
if (requireNamespace("tmap", quietly = TRUE)) {
  library(tmap)

tm_shape(flows_clustered) +
  tm_lines(
  lwd = "count",
  col = "grey30",
  alpha = 0.7,
  title.lwd = "No. of people (Original flows)",
  scale = 10,
  legend.col.show = FALSE,
  showNA = FALSE) +
tm_facets(
  by = "cluster",
  free.coords = FALSE,
  nrow = 3,
  showNA = FALSE) +
tm_shape(flows_agg_w) +
tm_lines(
  lwd = "count_total",
  col = "red",
  palette = "Accent", # YlGn
  alpha = 1,
  title.col = "Cluster",
  title.lwd = "No. of people (Representative linestring)",
  scale = 10,
  legend.outside = TRUE,
  legend.outside.position = "bottom") +
 tm_facets(
   by = "cluster",
   free.coords = FALSE,
   nrow = 4,
   showNA = FALSE) +
 tm_layout(
   fontfamily = "Georgia",
   main.title = "Aggregating flows to representative linestrings per cluster",
   main.title.size = 1.1,
   main.title.color = "azure4",
   main.title.position = "left",
   legend.outside = TRUE,
   legend.outside.position = "bottom",
   legend.stack = "horizontal",
  ) 
 }
}
